using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FizzBuzzWhizz;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class FizzBuzzWhizz : IIncrementalGenerator
{
    private const string Namespace = "FizzBuzzWhizz";
    private const string AttributeName = "FizzBuzzWhizzAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
namespace {Namespace};

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {AttributeName} : System.Attribute
{{
    private {AttributeName}()
    {{
    }}

    /// <summary>
    /// An attribute to mark a partial class for processing by the {Namespace} engine.
    /// </summary>
    /// <param name=""rules"">
    /// A sequence of strings denoting one or many pairs.
    /// Every odd item must be a string value, every even item parsable to a long
    /// e.g. <c>[""Fizz"", ""3"", ""Buzz"", ""5""]</c>.
    /// </param>
    /// <exception cref=""System.ArgumentNullException""></exception>
    /// <exception cref=""System.ArgumentException""></exception>
    public {AttributeName}(params string[] rules)
    {{
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.Rules is not null)
            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right!));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the attribute and maps syntax context to the specific node type
    /// (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax Declaration, Dictionary<string, long[]>? Rules)
        GetClassDeclarationForSourceGen(
            GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        var rules = GetRulesFromAttributes(classDeclarationSyntax, context.SemanticModel);
        return (classDeclarationSyntax, rules);
    }

    private static Dictionary<string, long[]>? GetRulesFromAttributes(
        ClassDeclarationSyntax classDeclarationSyntax, SemanticModel semanticModel)
    {
        foreach (var attributeSyntax in classDeclarationSyntax.AttributeLists
                     .SelectMany(attributeListSyntax => attributeListSyntax.Attributes))
        {
            if (!IsFizzBuzzWhizzAttribute(attributeSyntax, semanticModel))
                continue;

            if (attributeSyntax.ArgumentList?.Arguments is not { Count: > 1 } arguments)
                continue;

            var rules = ParseRules(arguments);
            if (rules.Count > 0)
                return rules;
        }

        return null;
    }

    private static bool IsFizzBuzzWhizzAttribute(AttributeSyntax attributeSyntax, SemanticModel semanticModel)
    {
        var symbol = semanticModel.GetSymbolInfo(attributeSyntax).Symbol as IMethodSymbol;
        return symbol?.ContainingType.ToDisplayString() == $"{Namespace}.{AttributeName}";
    }

    private static Dictionary<string, long[]> ParseRules(SeparatedSyntaxList<AttributeArgumentSyntax> arguments)
    {
        var pairCount = arguments.Count / 2;
        var rules = new Dictionary<long, StringBuilder>(pairCount);
        for (var i = 0; i < pairCount * 2; i += 2)
        {
            if (arguments[i].Expression is not LiteralExpressionSyntax substituteLiteral ||
                !substituteLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression) ||
                arguments[i + 1].Expression is not LiteralExpressionSyntax numberLiteral ||
                !numberLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression))
            {
                continue;
            }

            var substitute = substituteLiteral.Token.ValueText;
            var numberString = numberLiteral.Token.ValueText;
            if (!long.TryParse(numberString, out var number)) continue;

            if (rules.ContainsKey(number))
            {
                // If the same number is already present, append the new substitute to the existing one.
                rules[number].Append(substitute);
            }
            else
            {
                // Otherwise, create a new entry.
                rules[number] = new StringBuilder(substitute);
            }
        }

        return rules
            .ToLookup(p => p.Value.ToString())
            .ToDictionary(
                p => p.Key,
                g => g.Select(p => p.Key).ToArray());
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes
    /// (ClassDeclarationSyntax annotated with the correctly configured attribute)
    /// changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="sites">Partial classes where an appropriately configured attribute is applied.</param>
    private void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax Declaration, Dictionary<string, long[]> Rules)> sites)
    {
        // Go through all filtered class declarations.
        foreach (var (declaration, rules) in sites)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(declaration.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(declaration) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = declaration.Identifier.Text;

            var identityMethodBody = GenerateIdentityBody(rules);

            // Build up the source code
            var code = $@"// <auto-generated/>
namespace {namespaceName};

partial class {className}
{{
    public string Identity(long n)
    {{
        if (n == 0)
        {{
            return ""0"";
        }}

{string.Join("\n", identityMethodBody)}
    }}
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private struct FlaggedSubstitute
    {
        public string Substitute { get; set; }
        public bool Matched { get; set; }
    }

    /// <summary>
    /// Generates the body of the Identity method as a switch expression incorporating pattern matching for all
    /// significant values.
    /// The modulus operation is performed exactly once based on the pre-calculated LCM of rules.
    /// </summary>
    private IEnumerable<string> GenerateIdentityBody(Dictionary<string, long[]> rules)
    {
        var substitutes = rules.ToDictionary(
            rule => rule.Key,
            rule => new FlaggedSubstitute{ Substitute = rule.Key, Matched = false });

        var rulesByNumber =
            rules.SelectMany(rule =>
                rule.Value.Select(number => (number, substitutes[rule.Key])))
                .ToDictionary(r => r.number, r => r.Item2);

        var numbers = rulesByNumber.Keys.ToArray();

        var mods = string.Join(", ", numbers.Select(number => $"n % {number}"));
        yield return $"        return ({mods}) switch";
        yield return "        {";
        foreach (var perm in GetBooleanPermutations(rulesByNumber.Count))
        {
            var (pattern, value) = GetPatternAndSubstitute(perm, numbers, rulesByNumber);
            yield return $"            {pattern} => \"{value}\",";
            ClearFlags(substitutes);
        }

        yield return "            _ => n.ToString()";
        yield return "        };";
    }

    private void ClearFlags(Dictionary<string, FlaggedSubstitute> substitutes)
    {
        foreach (var key in substitutes.Keys)
        {
            var substitute = substitutes[key];
            substitute.Matched = false;
        }
    }

    private static (string Pattern, string Substitute) GetPatternAndSubstitute(
        bool[] perm,
        long[] numbers,
        Dictionary<long, FlaggedSubstitute> rulesByNumber)
    {
        var parts = new string[perm.Length];
        var substitute = new StringBuilder();
        for (var i = 0; i < perm.Length; i++)
        {
            var selected = perm[i];
            parts[i] = selected ? "0" : "_";
            if (!selected) continue;

            var number = numbers[i];
            var flaggedSubstitute = rulesByNumber[number];
            if (flaggedSubstitute.Matched) continue;

            flaggedSubstitute.Matched = true;
            substitute.Append(flaggedSubstitute.Substitute);
        }

        return
        (
            $"({string.Join(", ", parts)})",
            substitute.ToString()
        );
    }

    private static IEnumerable<bool[]> GetBooleanPermutations(int n)
    {
        var total = 1 << n;
        for (int i = total - 1; i >= 1; i--)
        {
            var result = new bool[n];
            for (int bit = 0; bit < n; bit++)
                result[bit] = (i & (1 << bit)) != 0;
            yield return result;
        }
    }
}
