using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace FizzBuzzWhizz;

/// <summary>
/// A sample source generator that creates a custom report based on class properties. The target class should be annotated with the 'Generators.ReportAttribute' attribute.
/// When using the source code as a baseline, an incremental source generator is preferable because it reduces the performance overhead.
/// </summary>
[Generator]
public class FizzBuzzWhizz : IIncrementalGenerator
{
    private const string Namespace = "FizzBuzzWhizz";
    private const string AttributeName = "FizzBuzzWhizzAttribute";

    private const string AttributeSourceCode = $@"// <auto-generated/>
namespace {Namespace};

[System.AttributeUsage(System.AttributeTargets.Class)]
public class {AttributeName} : System.Attribute
{{
    private {AttributeName}()
    {{
    }}

    /// <summary>
    /// An attribute to mark a partial class for processing by the {Namespace} engine.
    /// </summary>
    /// <param name=""rules"">
    /// A sequence of strings denoting one or many pairs.
    /// Every odd item must be a string value, every even item parsable to a long
    /// e.g. <c>[""Fizz"", ""3"", ""Buzz"", ""5""]</c>.
    /// </param>
    /// <exception cref=""System.ArgumentNullException""></exception>
    /// <exception cref=""System.ArgumentException""></exception>
    public {AttributeName}(params string[] rules)
    {{
    }}
}}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Add the marker attribute to the compilation.
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            $"{AttributeName}.g.cs",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));

        // Filter classes annotated with the attribute. Only filtered Syntax Nodes can trigger code generation.
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                (s, _) => s is ClassDeclarationSyntax,
                (ctx, _) => GetClassDeclarationForSourceGen(ctx))
            .Where(t => t.Rules is not null)
            .Select((t, _) => t);

        // Generate the source code.
        context.RegisterSourceOutput(context.CompilationProvider.Combine(provider.Collect()),
            (ctx, t) => GenerateCode(ctx, t.Left, t.Right!));
    }

    /// <summary>
    /// Checks whether the Node is annotated with the attribute and maps syntax context to the specific node type
    /// (ClassDeclarationSyntax).
    /// </summary>
    /// <param name="context">Syntax context, based on CreateSyntaxProvider predicate</param>
    /// <returns>The specific cast and whether the attribute was found.</returns>
    private static (ClassDeclarationSyntax Declaration, KeyValuePair<string, long>[]? Rules) GetClassDeclarationForSourceGen(
        GeneratorSyntaxContext context)
    {
        var classDeclarationSyntax = (ClassDeclarationSyntax)context.Node;
        KeyValuePair<string, long>[]? rules = null;

        // Go through all attributes of the class.
        foreach (var attributeListSyntax in classDeclarationSyntax.AttributeLists)
        foreach (var attributeSyntax in attributeListSyntax.Attributes)
        {
            if (context.SemanticModel.GetSymbolInfo(attributeSyntax).Symbol is not IMethodSymbol attributeSymbol)
            {
                continue; // if we can't get the symbol, ignore it
            }

            var attributeName = attributeSymbol.ContainingType.ToDisplayString();

            // Check the full name of the  attribute.
            if (attributeName != $"{Namespace}.{AttributeName}")
            {
                continue;
            }

            if (attributeSyntax.ArgumentList?.Arguments is not { Count: > 1 } arguments)
            {
                continue; //ignore attributes without arguments
            }

            var pairCount = arguments.Count / 2; // ignore an odd tail if it exists
            var newRules = new List<KeyValuePair<string, long>>(pairCount);
            for (var i = 0; i < pairCount * 2; i += 2)
            {
                // the arguments should be paired strings
                if (arguments[i].Expression is not LiteralExpressionSyntax keyLiteral ||
                    !keyLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression) ||
                    arguments[i + 1].Expression is not LiteralExpressionSyntax valueLiteral ||
                    !valueLiteral.IsKind(Microsoft.CodeAnalysis.CSharp.SyntaxKind.StringLiteralExpression))
                {
                    // if the argument pair is not a string literals, ignore them
                    continue;
                }

                var key = keyLiteral.Token.ValueText;
                var valueString = valueLiteral.Token.ValueText;
                if (long.TryParse(valueString, out var value))
                {
                    //every second argument should be parsable to long
                    newRules.Add(new KeyValuePair<string, long>(key, value));
                }
            }

            if (newRules.Count > 0)
            {
                rules = newRules.ToArray();
            }
        }

        return (classDeclarationSyntax, rules);
    }

    /// <summary>
    /// Generate code action.
    /// It will be executed on specific nodes
    /// (ClassDeclarationSyntax annotated with the correctly configured attribute)
    /// changed by the user.
    /// </summary>
    /// <param name="context">Source generation context used to add source files.</param>
    /// <param name="compilation">Compilation used to provide access to the Semantic Model.</param>
    /// <param name="sites">Partial classes where an appropriately configured attribute is applied.</param>
    private void GenerateCode(
        SourceProductionContext context,
        Compilation compilation,
        ImmutableArray<(ClassDeclarationSyntax Declaration, KeyValuePair<string, long>[] Rules)> sites)
    {
        // Go through all filtered class declarations.
        foreach (var (declaration, rules) in sites)
        {
            // We need to get semantic model of the class to retrieve metadata.
            var semanticModel = compilation.GetSemanticModel(declaration.SyntaxTree);

            // Symbols allow us to get the compile-time information.
            if (semanticModel.GetDeclaredSymbol(declaration) is not INamedTypeSymbol classSymbol)
                continue;

            var namespaceName = classSymbol.ContainingNamespace.ToDisplayString();

            // 'Identifier' means the token of the node. Get class name from the syntax node.
            var className = declaration.Identifier.Text;

            var identityMethodBody = GenerateIdentityBody(rules);

            // Build up the source code
            var code = $@"// <auto-generated/>
namespace {namespaceName};

partial class {className}
{{
    public string Identity(long n) => n switch
    {{
{string.Join("\n", identityMethodBody)}
        _ => n.ToString()
    }};
}}
";

            // Add the source code to the compilation.
            context.AddSource($"{className}.g.cs", SourceText.From(code, Encoding.UTF8));
        }
    }

    private IEnumerable<string> GenerateIdentityBody(KeyValuePair<string, long>[] rules)
    {
        var cases = new Dictionary<long, string>();
        foreach (var combination in GetAllCombinations(rules))
        {
            long multiple = 1;
            StringBuilder response = new();
            foreach (var pair in combination)
            {
                multiple *= pair.Value;
                response.Append(pair.Key);
            }

            if (cases.ContainsKey(multiple))
            {
                response.Append(", ");
                response.Append(cases[multiple]);
                cases[multiple] = response.ToString();
            }
            else
            {
                cases.Add(multiple, response.ToString());
            }
        }

        foreach (var @case in cases.OrderByDescending(c => c.Key))
        {
            yield return $"        {@case.Key} => \"{@case.Value}\",";
        }
    }

    private static IEnumerable<IEnumerable<T>> GetAllCombinations<T>(IEnumerable<T> items)
    {
        var list = items.ToList();
        var n = list.Count;
        for (var length = 1; length <= n; length++)
        {
            foreach (var combination in GetCombinations(list, length))
                yield return combination;
        }
    }

    private static IEnumerable<IEnumerable<T>> GetCombinations<T>(IList<T> list, int length)
    {
        if (length == 0)
            yield return [];
        else
        {
            for (var i = 0; i <= list.Count - length; i++)
            {
                foreach (var tail in GetCombinations(list.Skip(i + 1).ToList(), length - 1))
                    yield return new[] { list[i] }.Concat(tail);
            }
        }
    }
}
